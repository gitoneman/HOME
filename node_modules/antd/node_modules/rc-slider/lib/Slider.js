'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcTooltip = require('rc-tooltip');

var _rcTooltip2 = _interopRequireDefault(_rcTooltip);

var _rcUtil = require('rc-util');

var _rcUtil2 = _interopRequireDefault(_rcUtil);

function noop() {}

function pauseEvent(e) {
  e.cancelBubble = true;
  e.returnValue = false;
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  if (e.preventDefault) {
    e.preventDefault();
  }
}

function prefixClsFn(prefixCls) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return args.map(function (s) {
    return prefixCls + '-' + s;
  }).join(' ');
}

function getValueFromIndex(props) {
  var value = undefined;
  var marksLen = props.marks.length;
  var index = undefined;
  if ('index' in props) {
    index = props.index;
  } else {
    index = props.defaultIndex;
  }
  if (marksLen > 0) {
    value = (props.max - props.min) / (marksLen - 1) * index;
    value = value.toFixed(5) / 1;
  }
  return value;
}

var Slider = _react2['default'].createClass({
  displayName: 'Slider',

  propTypes: {
    min: _react2['default'].PropTypes.number,
    max: _react2['default'].PropTypes.number,
    step: _react2['default'].PropTypes.number,
    defaultValue: _react2['default'].PropTypes.number,
    defaultIndex: _react2['default'].PropTypes.number,
    value: _react2['default'].PropTypes.number,
    index: _react2['default'].PropTypes.number,
    marks: _react2['default'].PropTypes.array,
    isIncluded: _react2['default'].PropTypes.bool,
    className: _react2['default'].PropTypes.string,
    prefixCls: _react2['default'].PropTypes.string,
    disabled: _react2['default'].PropTypes.bool,
    children: _react2['default'].PropTypes.any,
    onBeforeChange: _react2['default'].PropTypes.func,
    onChange: _react2['default'].PropTypes.func,
    onAfterChange: _react2['default'].PropTypes.func,
    tipTransitionName: _react2['default'].PropTypes.string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      min: 0,
      max: 100,
      step: 1,
      defaultValue: 0,
      marks: [],
      isIncluded: true,
      className: '',
      prefixCls: 'rc-slider',
      disabled: false,
      defaultIndex: 0,
      tipTransitionName: ''
    };
  },

  getInitialState: function getInitialState() {
    var props = this.props;
    var value = props.defaultValue;
    if ('value' in props) {
      value = props.value;
    }
    value = this._trimAlignValue(value);
    var marksLen = props.marks.length;
    if (marksLen > 0) {
      value = getValueFromIndex(props);
    }
    return {
      dragging: false,
      showTooltip: false,
      value: value
    };
  },

  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if ('value' in nextProps) {
      this.setState({
        value: nextProps.value
      });
    } else if ('index' in nextProps) {
      this.setState({
        value: getValueFromIndex(nextProps)
      });
    }
  },

  onMouseUp: function onMouseUp(e) {
    var m = e.target;
    var handleDom = _react2['default'].findDOMNode(this.refs.handle);
    var showToolTip = false;
    if (m === handleDom) {
      showToolTip = true;
    }
    this._end('mouse', showToolTip);
  },

  onTouchUp: function onTouchUp() {
    this._end('touch');
  },

  onMouseMove: function onMouseMove(e) {
    var position = e.pageX || e.clientX + document.documentElement.scrollLeft; // to compat ie8
    this.onMove(e, position);
  },

  onTouchMove: function onTouchMove(e) {
    if (e.touches.length > 1 || e.type === 'touchend' && e.touches.length > 0) {
      this._end('touch');
      return;
    }

    var position = this._getTouchPosition(e);

    this.onMove(e, position);
  },

  onMove: function onMove(e, position) {
    pauseEvent(e);
    var props = this.props;
    var state = this.state;

    var value = state.value;
    var oldValue = value;

    var diffPosition = position - this.startPosition;

    var diffValue = diffPosition / this.getSliderLength() * (props.max - props.min);
    value = this._trimAlignValue(this.startValue + diffValue);

    if (value !== oldValue && !('value' in props) && !('index' in props)) {
      this.setState({ value: value });
    }
    if (value !== oldValue) {
      this._triggerEvents('onChange', value);
    }
  },

  onTouchStart: function onTouchStart(e) {
    if (e.touches.length > 1 || e.type.toLowerCase() === 'touchend' && e.touches.length > 0) {
      return;
    }

    var position = this._getTouchPosition(e);
    var value = this._calValueByPos(position);
    this._triggerEvents('onChange', value);
    this._start(position, value);
    this._addDocumentEvents('touch');
    pauseEvent(e);
  },

  onSliderMouseDown: function onSliderMouseDown(e) {
    var position = e.pageX || e.clientX + document.documentElement.scrollLeft; // to compat ie8
    var value = this._calValueByPos(position);
    this._triggerEvents('onChange', value);
    this._start(position, value);
    this._addDocumentEvents('mouse');
    pauseEvent(e);
  },

  getIndex: function getIndex(v) {
    var props = this.props;
    var value = v === undefined ? this.state.value : v;

    if (props.marks.length === 0) {
      return Math.floor((value - props.min) / props.step);
    }
    var unit = ((props.max - props.min) / (props.marks.length - 1)).toFixed(5);
    return Math.round(value / unit);
  },

  getSliderLength: function getSliderLength() {
    var slider = this.refs.slider;
    if (!slider) {
      return 0;
    }

    return slider.getDOMNode().clientWidth;
  },

  getSliderStart: function getSliderStart() {
    var slider = this.refs.slider.getDOMNode();
    var rect = slider.getBoundingClientRect();

    return rect.left;
  },

  renderSteps: function renderSteps() {
    var props = this.props;
    var marksLen = props.marks.length;
    var stepNum = marksLen > 0 ? marksLen : Math.floor((props.max - props.min) / props.step) + 1;
    var unit = 100 / (stepNum - 1);

    var prefixCls = props.prefixCls;
    var stepClassName = prefixClsFn(prefixCls, 'step');

    var elements = [];
    for (var i = 0; i < stepNum; i++) {
      var offset = unit * i + '%';
      var style = {
        left: offset
      };
      var className = prefixClsFn(prefixCls, 'dot');
      if (props.isIncluded) {
        if (i <= this.getIndex()) {
          className = prefixClsFn(prefixCls, 'dot', 'dot-active');
        }
      } else {
        className = i === this.getIndex() ? prefixClsFn(prefixCls, 'dot', 'dot-active') : className;
      }

      elements[i] = _react2['default'].createElement('span', { className: className, style: style, ref: 'step' + i, key: 'step' + i });
    }

    return _react2['default'].createElement(
      'div',
      { className: stepClassName },
      elements
    );
  },

  renderMark: function renderMark(i) {
    var marks = this.props.marks;
    var marksLen = marks.length;
    var unit = 100 / (marksLen - 1);
    var offset = unit * i;

    var style = {
      width: unit / 2 + '%'
    };

    if (i === marksLen - 1) {
      style.right = -unit / 4 + '%';
    } else {
      style.left = i > 0 ? offset - unit / 4 + '%' : -unit / 4 + '%';
    }

    var prefixCls = this.props.prefixCls;
    var className = prefixClsFn(prefixCls, 'mark-text');

    if (this.props.isIncluded) {
      if (i <= this.getIndex()) {
        className = prefixClsFn(prefixCls, 'mark-text', 'mark-text-active');
      }
    } else {
      className = i === this.getIndex() ? prefixClsFn(prefixCls, 'mark-text', 'mark-text-active') : className;
    }

    return _react2['default'].createElement(
      'span',
      { className: className, style: style, key: i },
      this.props.marks[i]
    );
  },

  renderMarks: function renderMarks() {
    var marks = this.props.marks;
    var marksLen = marks.length;
    var elements = [];
    for (var i = 0; i < marksLen; i++) {
      elements[i] = this.renderMark(i);
    }

    var prefixCls = this.props.prefixCls;
    var className = prefixClsFn(prefixCls, 'mark');

    return _react2['default'].createElement(
      'div',
      { className: className },
      elements
    );
  },

  renderHandler: function renderHandler(offset) {
    var onStyle = {
      left: offset
    };

    var prefixCls = this.props.prefixCls;
    var className = prefixClsFn(prefixCls, 'handle');

    var events = {};

    var tooltipVisible = undefined;

    if (this.state.dragging) {
      tooltipVisible = true;
    } else {
      events = {
        onClick: this.showTooltip.bind(this, true),
        onMouseEnter: this.showTooltip.bind(this, true),
        onMouseLeave: this.showTooltip.bind(this, false)
      };
      tooltipVisible = this.state.showTooltip;
    }

    var handle = _react2['default'].createElement('div', _extends({ className: className
    }, events, {
      ref: 'handle',
      style: onStyle }));

    if (this.props.marks.length > 0) {
      return handle;
    }
    return _react2['default'].createElement(
      _rcTooltip2['default'],
      {
        placement: { points: ['bc', 'tc'] },
        visible: tooltipVisible,
        overlay: _react2['default'].createElement(
          'span',
          null,
          this.state.value
        ),
        delay: 0,
        transitionName: this.props.tipTransitionName,
        prefixCls: prefixClsFn(prefixCls, 'tooltip') },
      handle
    );
  },

  renderTrack: function renderTrack(offset) {
    var style = {
      width: offset
    };

    var prefixCls = this.props.prefixCls;
    var trackClassName = prefixClsFn(prefixCls, 'track');

    return _react2['default'].createElement('div', { className: trackClassName, ref: 'track', style: style });
  },

  render: function render() {
    var _sliderClassName;

    var state = this.state;
    var props = this.props;
    var value = state.value;
    var offset = this._calcOffset(value);
    var track = this.props.isIncluded ? this.renderTrack(offset) : null;
    var ons = this.renderHandler(offset);
    var steps = props.step > 1 || props.marks.length > 0 ? this.renderSteps() : null;
    var sliderMarks = props.marks.length > 0 ? this.renderMarks() : null;
    var prefixCls = props.prefixCls;
    var disabled = props.disabled;
    var sliderClassName = (_sliderClassName = {}, _defineProperty(_sliderClassName, prefixCls, 1), _defineProperty(_sliderClassName, props.className, !!props.className), _defineProperty(_sliderClassName, prefixCls + '-disabled', disabled), _sliderClassName);

    return _react2['default'].createElement(
      'div',
      { className: _rcUtil2['default'].classSet(sliderClassName), ref: 'slider',
        onTouchStart: disabled ? noop : this.onTouchStart,
        onMouseDown: disabled ? noop : this.onSliderMouseDown },
      track,
      ons,
      steps,
      sliderMarks,
      this.props.children
    );
  },

  showTooltip: function showTooltip(show) {
    this.setState({
      showTooltip: show
    });
  },

  _trimAlignValue: function _trimAlignValue(v, propsArg) {
    var val = v;
    var props = propsArg || this.props;
    var step = props.marks.length > 0 ? (props.max - props.min) / (props.marks.length - 1) : props.step;

    if (val <= props.min) {
      val = props.min;
    }
    if (val >= props.max) {
      val = props.max;
    }

    var valModStep = (val - props.min) % step;
    var alignValue = val - valModStep;

    if (Math.abs(valModStep) * 2 >= step) {
      alignValue += valModStep > 0 ? step : -step;
    }

    return parseFloat(alignValue.toFixed(5));
  },

  _calcOffset: function _calcOffset(value) {
    var ratio = (value - this.props.min) / (this.props.max - this.props.min);
    return ratio * 100 + '%';
  },

  _calcValue: function _calcValue(offset) {
    var ratio = offset / this.getSliderLength();
    return ratio * (this.props.max - this.props.min) + this.props.min;
  },

  _calValueByPos: function _calValueByPos(position) {
    var pixelOffset = position - this.getSliderStart();
    // pixelOffset -= (this.state.onSize / 2);
    var nextValue = this._trimAlignValue(this._calcValue(pixelOffset));
    this.setState({
      value: nextValue
    });
    return nextValue;
  },

  _getTouchPosition: function _getTouchPosition(e) {
    var touch = e.touches[0];
    return touch.pageX;
  },

  _triggerEvents: function _triggerEvents(event, v) {
    var props = this.props;
    var hasMarks = props.marks && props.marks.length > 0;
    if (props[event]) {
      var data = undefined;
      if (hasMarks) {
        data = this.getIndex(v);
      } else if (v === undefined) {
        data = this.state.value;
      } else {
        data = v;
      }
      props[event](data);
    }
  },

  _addDocumentEvents: function _addDocumentEvents(type) {
    if (type === 'touch') {
      // just work for chrome iOS Safari and Android Browser
      this.onTouchMoveListener = _rcUtil.Dom.addEventListener(document, 'touchmove', this.onTouchMove);
      this.onTouchUpListener = _rcUtil.Dom.addEventListener(document, 'touchend', this.onTouchUp);
    } else if (type === 'mouse') {
      this.onMouseMoveListener = _rcUtil.Dom.addEventListener(document, 'mousemove', this.onMouseMove);
      this.onMouseUpListener = _rcUtil.Dom.addEventListener(document, 'mouseup', this.onMouseUp);
    }
  },

  _removeEventons: function _removeEventons(type) {
    if (type === 'touch') {
      this.onTouchMoveListener.remove();
      this.onTouchUpListener.remove();
    } else if (type === 'mouse') {
      this.onMouseMoveListener.remove();
      this.onMouseUpListener.remove();
    }
  },

  _start: function _start(position, value) {
    this._triggerEvents('onBeforeChange');
    this.startValue = value;
    this.startPosition = position;
    this.setState({
      dragging: true
    });
  },

  _end: function _end(type, showToolTip) {
    this._removeEventons(type);
    this._triggerEvents('onAfterChange');
    this.setState({
      dragging: false,
      showTooltip: !!showToolTip
    });
  }
});

exports['default'] = Slider;
module.exports = exports['default'];