'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcUtil = require('rc-util');

var _rcUtil2 = _interopRequireDefault(_rcUtil);

var _Track = require('./Track');

var _Track2 = _interopRequireDefault(_Track);

var _Handle = require('./Handle');

var _Handle2 = _interopRequireDefault(_Handle);

var _Steps = require('./Steps');

var _Steps2 = _interopRequireDefault(_Steps);

var _Marks = require('./Marks');

var _Marks2 = _interopRequireDefault(_Marks);

function noop() {}

function isNotTouchEvent(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === 'touchend' && e.touches.length > 0;
}

function getTouchPosition(e) {
  return e.touches[0].pageX;
}

function getMousePosition(e) {
  return e.pageX || e.clientX + document.documentElement.scrollLeft; // to compat ie8
}

function pauseEvent(e) {
  e.cancelBubble = true;
  e.returnValue = false;
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  if (e.preventDefault) {
    e.preventDefault();
  }
}

var Slider = (function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, props);

    var upperBound = undefined;
    var lowerBound = undefined;
    if (props.range) {
      var value = props.value || props.defaultValue || [0, 0];
      upperBound = this.trimAlignValue(value[1]);
      lowerBound = this.trimAlignValue(value[0]);
    } else if (props.marks.length > 0) {
      upperBound = this.calcValueFromProps(props);
    } else {
      // Note: Maybe `value` is `0`.
      //       So, check the existence of `value` with `in`.
      var defaultValue = 'defaultValue' in props ? props.defaultValue : 0;
      var value = 'value' in props ? props.value : defaultValue;
      upperBound = this.trimAlignValue(value);
    }

    var recent = undefined;
    if (props.range && upperBound === lowerBound) {
      if (lowerBound === props.max) {
        recent = 'lowerBound';
      }
      if (upperBound === props.min) {
        recent = 'upperBound';
      }
    } else {
      recent = 'upperBound';
    }

    this.state = {
      handle: null,
      recent: recent,
      upperBound: upperBound,
      // If Slider is not range, set `lowerBound` equal to `min`.
      lowerBound: lowerBound || props.min
    };
  }

  _createClass(Slider, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.range) {
        var value = nextProps.value;
        if (value) {
          this.setState({
            upperBound: value[1],
            lowerBound: value[0]
          });
        }
      } else if ('value' in nextProps) {
        this.setState({
          upperBound: nextProps.value
        });
      } else if ('index' in nextProps) {
        this.setState({
          upperBound: this.calcValueFromProps(nextProps)
        });
      }
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var position = getMousePosition(e);
      this.onMove(e, position);
    }
  }, {
    key: 'onTouchMove',
    value: function onTouchMove(e) {
      if (isNotTouchEvent(e)) {
        this.end('touch');
        return;
      }

      var position = getTouchPosition(e);
      this.onMove(e, position);
    }
  }, {
    key: 'onMove',
    value: function onMove(e, position) {
      pauseEvent(e);
      var props = this.props;
      var state = this.state;

      var diffPosition = position - this.startPosition;
      var diffValue = diffPosition / this.getSliderLength() * (props.max - props.min);

      var value = this.trimAlignValue(this.startValue + diffValue);
      var oldValue = state[state.handle];
      if (value === oldValue) return;

      if (!('value' in props) && !('index' in props)) {
        this.setState(_defineProperty({}, state.handle, value));
      }

      if (props.range) {
        // `this.state` will not be updated immediately after `this.setState`.
        // So, create a similar object.
        // const data = Object.assign({}, state, {[state.handle]: value});
        var data = {
          upperBound: state.upperBound,
          lowerBound: state.lowerBound
        };
        data[state.handle] = value;
        this.triggerEvents('onChange', [data.lowerBound, data.upperBound]);
      } else {
        this.triggerEvents('onChange', value);
      }
    }
  }, {
    key: 'onTouchStart',
    value: function onTouchStart(e) {
      if (isNotTouchEvent(e)) return;

      var position = getTouchPosition(e);
      this.onStart(position);
      this.addDocumentEvents('touch');
      pauseEvent(e);
    }
  }, {
    key: 'onSliderMouseDown',
    value: function onSliderMouseDown(e) {
      var position = getMousePosition(e);
      this.onStart(position);
      this.addDocumentEvents('mouse');
      pauseEvent(e);
    }
  }, {
    key: 'onStart',
    value: function onStart(position) {
      this.triggerEvents('onBeforeChange');

      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;

      var state = this.state;
      var upperBound = state.upperBound;
      var lowerBound = state.lowerBound;

      var valueNeedChanging = 'upperBound';
      if (this.props.range) {
        var isLowerBoundCloser = Math.abs(upperBound - value) > Math.abs(lowerBound - value);
        if (isLowerBoundCloser) {
          valueNeedChanging = 'lowerBound';
        }

        var isAtTheSamePoint = upperBound === lowerBound;
        if (isAtTheSamePoint) {
          valueNeedChanging = state.recent;
        }

        if (isAtTheSamePoint && value !== upperBound) {
          valueNeedChanging = value < upperBound ? 'lowerBound' : 'upperBound';
        }
      }

      this.setState(_defineProperty({
        handle: valueNeedChanging,
        recent: valueNeedChanging
      }, valueNeedChanging, value));

      if (this.props.range) {
        // const data = Object.assign({}, state, {[valueNeedChanging]: value});
        var data = {
          upperBound: state.upperBound,
          lowerBound: state.lowerBound
        };
        data[valueNeedChanging] = value;
        this.triggerEvents('onChange', [data.lowerBound, data.upperBound]);
      } else {
        this.triggerEvents('onChange', value);
      }
    }
  }, {
    key: 'getIndex',
    value: function getIndex(value) {
      var _props = this.props;
      var marks = _props.marks;
      var min = _props.min;
      var max = _props.max;
      var step = _props.step;

      if (marks.length === 0) {
        return Math.floor((value - min) / step);
      }
      var unit = ((max - min) / (marks.length - 1)).toFixed(5);
      return Math.round(value / unit);
    }
  }, {
    key: 'getSliderLength',
    value: function getSliderLength() {
      var slider = this.refs.slider;
      if (!slider) {
        return 0;
      }

      return slider.clientWidth;
    }
  }, {
    key: 'getSliderStart',
    value: function getSliderStart() {
      var slider = this.refs.slider;
      var rect = slider.getBoundingClientRect();

      return rect.left;
    }
  }, {
    key: 'trimAlignValue',
    value: function trimAlignValue(v) {
      var state = this.state || {};
      var props = this.props;
      var marks = props.marks;
      var min = props.min;
      var max = props.max;

      var step = marks.length > 0 ? (max - min) / (marks.length - 1) : props.step;

      var val = v;
      if (val <= min) {
        val = min;
      }
      if (val >= max) {
        val = max;
      }
      if (state.handle === 'upperBound' && val <= state.lowerBound) {
        val = state.lowerBound;
      }
      if (state.handle === 'lowerBound' && val >= state.upperBound) {
        val = state.upperBound;
      }

      var valModStep = (val - min) % step;
      var alignValue = val - valModStep;

      if (Math.abs(valModStep) * 2 >= step) {
        alignValue += valModStep > 0 ? step : -step;
      }

      return parseFloat(alignValue.toFixed(5));
    }
  }, {
    key: 'calcOffset',
    value: function calcOffset(value) {
      var _props2 = this.props;
      var min = _props2.min;
      var max = _props2.max;

      var ratio = (value - min) / (max - min);
      return ratio * 100;
    }
  }, {
    key: 'calcValue',
    value: function calcValue(offset) {
      var _props3 = this.props;
      var min = _props3.min;
      var max = _props3.max;

      var ratio = offset / this.getSliderLength();
      return ratio * (max - min) + min;
    }
  }, {
    key: 'calcValueByPos',
    value: function calcValueByPos(position) {
      var pixelOffset = position - this.getSliderStart();
      var nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
      return nextValue;
    }
  }, {
    key: 'calcValueFromProps',
    value: function calcValueFromProps(props) {
      var marksLen = props.marks.length;
      if (marksLen > 0) {
        var index = 'index' in props ? props.index : props.defaultIndex;
        var value = (props.max - props.min) / (marksLen - 1) * index;
        // `'1' / 1 => 1`, to make sure that the returned value is a `Number`.
        return value.toFixed(5) / 1;
      }
      return 'value' in props ? props.value : props.defaultValue;
    }
  }, {
    key: 'triggerEvents',
    value: function triggerEvents(event, v) {
      var props = this.props;
      var hasMarks = props.marks.length > 0;
      if (props[event]) {
        var data = undefined;
        if (hasMarks) {
          data = this.getIndex(v);
        } else if (v === undefined) {
          data = this.state.value;
        } else {
          data = v;
        }
        props[event](data);
      }
    }
  }, {
    key: 'addDocumentEvents',
    value: function addDocumentEvents(type) {
      if (type === 'touch') {
        // just work for chrome iOS Safari and Android Browser
        this.onTouchMoveListener = _rcUtil.Dom.addEventListener(document, 'touchmove', this.onTouchMove.bind(this));
        this.onTouchUpListener = _rcUtil.Dom.addEventListener(document, 'touchend', this.end.bind(this, 'touch'));
      } else if (type === 'mouse') {
        this.onMouseMoveListener = _rcUtil.Dom.addEventListener(document, 'mousemove', this.onMouseMove.bind(this));
        this.onMouseUpListener = _rcUtil.Dom.addEventListener(document, 'mouseup', this.end.bind(this, 'mouse'));
      }
    }
  }, {
    key: 'removeEventons',
    value: function removeEventons(type) {
      if (type === 'touch') {
        this.onTouchMoveListener.remove();
        this.onTouchUpListener.remove();
      } else if (type === 'mouse') {
        this.onMouseMoveListener.remove();
        this.onMouseUpListener.remove();
      }
    }
  }, {
    key: 'end',
    value: function end(type) {
      this.removeEventons(type);
      this.triggerEvents('onAfterChange');
      this.setState({ handle: null });
    }
  }, {
    key: 'render',
    value: function render() {
      var _rcUtil$classSet;

      var _state = this.state;
      var handle = _state.handle;
      var upperBound = _state.upperBound;
      var lowerBound = _state.lowerBound;

      var props = this.props;
      var className = props.className;
      var prefixCls = props.prefixCls;
      var disabled = props.disabled;
      var included = props.included;
      var isIncluded = props.isIncluded;
      var dots = props.dots;
      var withDots = props.withDots;
      var range = props.range;
      var marks = props.marks;
      var step = props.step;
      var max = props.max;
      var min = props.min;
      var tipTransitionName = props.tipTransitionName;
      var children = props.children;

      var marksLen = marks.length;

      var sliderClassName = _rcUtil2['default'].classSet((_rcUtil$classSet = {}, _defineProperty(_rcUtil$classSet, prefixCls, true), _defineProperty(_rcUtil$classSet, prefixCls + '-disabled', disabled), _defineProperty(_rcUtil$classSet, className, !!className), _rcUtil$classSet));

      var upperOffset = this.calcOffset(upperBound);
      var lowerOffset = this.calcOffset(lowerBound);

      var track = null;
      if (included && isIncluded || range) {
        var trackClassName = prefixCls + '-track';
        track = _react2['default'].createElement(_Track2['default'], { className: trackClassName, offset: lowerOffset, length: upperOffset - lowerOffset });
      }

      var handleClassName = prefixCls + '-handle';
      var isNoTip = marksLen > 0;
      var upper = _react2['default'].createElement(_Handle2['default'], { className: handleClassName, tipTransitionName: tipTransitionName, noTip: isNoTip,
        offset: upperOffset, value: upperBound, dragging: handle === 'upperBound' });

      var lower = null;
      if (range) {
        lower = _react2['default'].createElement(_Handle2['default'], { className: handleClassName, tipTransitionName: tipTransitionName, noTip: isNoTip,
          offset: lowerOffset, value: lowerBound, dragging: handle === 'lowerBound' });
      }

      var upperIndex = this.getIndex(upperBound);

      var steps = null;
      if (marksLen > 0 || step > 1 && (dots || withDots)) {
        var stepsClassName = prefixCls + '-step';
        var stepNum = marksLen > 0 ? marksLen : Math.floor((max - min) / step) + 1;
        steps = _react2['default'].createElement(_Steps2['default'], { className: stepsClassName, stepNum: stepNum,
          lowerIndex: this.getIndex(lowerBound), upperIndex: upperIndex,
          included: included && isIncluded || range });
      }

      var mark = null;
      if (marksLen > 0) {
        var markClassName = prefixCls + '-mark';
        mark = _react2['default'].createElement(_Marks2['default'], { className: markClassName, marks: marks,
          index: upperIndex, included: included && isIncluded });
      }

      return _react2['default'].createElement(
        'div',
        { ref: 'slider', className: sliderClassName,
          onTouchStart: disabled ? noop : this.onTouchStart.bind(this),
          onMouseDown: disabled ? noop : this.onSliderMouseDown.bind(this) },
        track,
        upper,
        lower,
        steps,
        mark,
        children
      );
    }
  }]);

  return Slider;
})(_react2['default'].Component);

Slider.propTypes = {
  min: _react2['default'].PropTypes.number,
  max: _react2['default'].PropTypes.number,
  step: _react2['default'].PropTypes.number,
  defaultValue: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  defaultIndex: _react2['default'].PropTypes.number,
  value: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  index: _react2['default'].PropTypes.number,
  marks: _react2['default'].PropTypes.array,
  isIncluded: _react2['default'].PropTypes.bool, // @Deprecated
  included: _react2['default'].PropTypes.bool,
  className: _react2['default'].PropTypes.string,
  prefixCls: _react2['default'].PropTypes.string,
  disabled: _react2['default'].PropTypes.bool,
  children: _react2['default'].PropTypes.any,
  onBeforeChange: _react2['default'].PropTypes.func,
  onChange: _react2['default'].PropTypes.func,
  onAfterChange: _react2['default'].PropTypes.func,
  tipTransitionName: _react2['default'].PropTypes.string,
  withDots: _react2['default'].PropTypes.bool, // @Deprecated
  dots: _react2['default'].PropTypes.bool,
  range: _react2['default'].PropTypes.bool
};

Slider.defaultProps = {
  min: 0,
  max: 100,
  step: 1,
  defaultIndex: 0,
  marks: [],
  isIncluded: true, // @Deprecated
  included: true,
  className: '',
  prefixCls: 'rc-slider',
  disabled: false,
  tipTransitionName: '',
  withDots: false, // @Deprecated
  dots: false,
  range: false
};

exports['default'] = Slider;
module.exports = exports['default'];