'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _utils = require('./utils');

var _rcAlign = require('rc-align');

var _rcAlign2 = _interopRequireDefault(_rcAlign);

var _rcAnimate = require('rc-animate');

var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

var placementAlignMap = {
  left: { points: ['cr', 'cl'] },
  right: { points: ['cl', 'cr'] },
  top: { points: ['bc', 'tc'] },
  bottom: { points: ['tc', 'bc'] }
};

var Popup = _react2['default'].createClass({
  displayName: 'Popup',

  propTypes: {
    visible: _react2['default'].PropTypes.bool,
    wrap: _react2['default'].PropTypes.object,
    style: _react2['default'].PropTypes.object,
    onMouseEnter: _react2['default'].PropTypes.func,
    onMouseLeave: _react2['default'].PropTypes.func
  },

  // optimize for speed
  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
    return this.props.visible || nextProps.visible;
  },

  onAlign: function onAlign(popupDomNode, align) {
    var props = this.props;
    var placement = props.placement;
    if (placement && placement.points) {
      var originalClassName = (0, _utils.getToolTipClassByPlacement)(props.prefixCls, placement);
      var nextClassName = (0, _utils.getToolTipClassByPlacement)(props.prefixCls, align);
      if (nextClassName !== originalClassName) {
        popupDomNode.className = popupDomNode.className.replace(originalClassName, nextClassName);
      }
    }
  },

  getPopupDomNode: function getPopupDomNode() {
    return _react2['default'].findDOMNode(this);
  },

  getTarget: function getTarget() {
    return _react2['default'].findDOMNode(this.props.wrap).firstChild;
  },

  getTransitionName: function getTransitionName() {
    var props = this.props;
    var transitionName = props.transitionName;
    if (!transitionName && props.animation) {
      transitionName = props.prefixCls + '-' + props.animation;
    }
    return transitionName;
  },

  render: function render() {
    var props = this.props;
    var className = (0, _utils.getToolTipClassByPlacement)(props.prefixCls, props.placement);
    if (props.className) {
      className += ' ' + props.className;
    }
    var style = this.props.style;
    if (!props.visible) {
      className += ' ' + props.prefixCls + '-hidden';
    }
    var arrowClassName = props.prefixCls + '-arrow';
    var innerClassname = props.prefixCls + '-inner';

    var placement = props.placement;
    var align = undefined;
    if (placement && placement.points) {
      align = placement;
    } else {
      align = placementAlignMap[placement];
    }

    return _react2['default'].createElement(
      _rcAnimate2['default'],
      { component: '',
        exclusive: true,
        transitionAppear: true,
        transitionName: this.getTransitionName(),
        showProp: 'data-visible' },
      _react2['default'].createElement(
        _rcAlign2['default'],
        { target: this.getTarget,
          key: 'popup',
          monitorWindowResize: true,
          'data-visible': props.visible,
          disabled: !props.visible,
          align: align,
          onAlign: this.onAlign },
        _react2['default'].createElement(
          'div',
          { className: className,
            onMouseEnter: props.onMouseEnter,
            onMouseLeave: props.onMouseLeave,
            style: style },
          _react2['default'].createElement('div', { className: arrowClassName }),
          _react2['default'].createElement(
            'div',
            { className: innerClassname },
            props.children
          )
        )
      )
    );
  }
});

exports['default'] = Popup;
module.exports = exports['default'];