'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _rcUtil = require('rc-util');

var _Popup = require('./Popup');

var _Popup2 = _interopRequireDefault(_Popup);

var Tooltip = _react2['default'].createClass({
  displayName: 'Tooltip',

  propTypes: {
    trigger: _react.PropTypes.any,
    placement: _react.PropTypes.any,
    onVisibleChange: _react.PropTypes.func,
    afterVisibleChange: _react.PropTypes.func,
    overlay: _react.PropTypes.node.isRequired,
    overlayStyle: _react.PropTypes.object,
    overlayClassName: _react.PropTypes.string,
    wrapStyle: _react.PropTypes.object,
    mouseEnterDelay: _react.PropTypes.number,
    mouseLeaveDelay: _react.PropTypes.number,
    getTooltipContainer: _react.PropTypes.func,
    align: _react.PropTypes.shape({
      offset: _react.PropTypes.array,
      targetOffset: _react.PropTypes.array
    })
  },

  getDefaultProps: function getDefaultProps() {
    return {
      prefixCls: 'rc-tooltip',
      onVisibleChange: function onVisibleChange() {},
      afterVisibleChange: function afterVisibleChange() {},
      mouseEnterDelay: 0,
      mouseLeaveDelay: 0.1,
      overlayStyle: {},
      wrapStyle: {},
      align: {},
      placement: 'right',
      trigger: ['hover']
    };
  },

  getInitialState: function getInitialState() {
    var props = this.props;
    var visible = undefined;
    if ('visible' in props) {
      visible = props.visible;
    } else {
      visible = props.defaultVisible;
    }
    return { visible: visible };
  },

  componentDidMount: function componentDidMount() {
    this.componentDidUpdate(this.props, this.state);
  },

  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if ('visible' in nextProps) {
      this.setState({
        visible: !!nextProps.visible
      });
    }
  },

  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    var _this = this;

    var props = this.props;
    var state = this.state;
    if (this.popupRendered) {
      var _ret = (function () {
        var self = _this;
        _reactDom2['default'].unstable_renderSubtreeIntoContainer(_this, _this.getPopupElement(), _this.getTipContainer(), function renderPopup() {
          self.popupDomNode = _reactDom2['default'].findDOMNode(this);
          if (prevState.visible !== state.visible) {
            props.afterVisibleChange(state.visible);
          }
        });
        if (props.trigger.indexOf('click') !== -1) {
          if (state.visible) {
            if (!_this.clickOutsideHandler) {
              _this.clickOutsideHandler = _rcUtil.Dom.addEventListener(document, 'mousedown', _this.onDocumentClick);
              _this.touchOutsideHandler = _rcUtil.Dom.addEventListener(document, 'touchstart', _this.onDocumentClick);
            }
            return {
              v: undefined
            };
          }
        }
        if (_this.clickOutsideHandler) {
          _this.clickOutsideHandler.remove();
          _this.touchOutsideHandler.remove();
          _this.clickOutsideHandler = null;
          _this.touchOutsideHandler = null;
        }
      })();

      if (typeof _ret === 'object') return _ret.v;
    }
  },

  componentWillUnmount: function componentWillUnmount() {
    var tipContainer = this.tipContainer;
    if (tipContainer) {
      _reactDom2['default'].unmountComponentAtNode(tipContainer);
      if (this.props.getTooltipContainer) {
        var mountNode = this.props.getTooltipContainer();
        mountNode.removeChild(tipContainer);
      } else {
        document.body.removeChild(tipContainer);
      }
      this.tipContainer = null;
    }
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
    if (this.clickOutsideHandler) {
      this.clickOutsideHandler.remove();
      this.touchOutsideHandler.remove();
      this.clickOutsideHandler = null;
      this.touchOutsideHandler = null;
    }
  },

  onMouseEnter: function onMouseEnter() {
    this.delaySetVisible(true, this.props.mouseEnterDelay);
  },

  onMouseLeave: function onMouseLeave() {
    this.delaySetVisible(false, this.props.mouseLeaveDelay);
  },

  onFocus: function onFocus() {
    this.focusTime = Date.now();
    this.setVisible(true);
  },

  onMouseDown: function onMouseDown() {
    this.preClickTime = Date.now();
  },

  onTouchStart: function onTouchStart() {
    this.preTouchTime = Date.now();
  },

  onBlur: function onBlur() {
    this.setVisible(false);
  },

  onClick: function onClick(event) {
    // focus will trigger click
    if (this.focusTime) {
      var preTime = undefined;
      if (this.preClickTime && this.preTouchTime) {
        preTime = Math.min(this.preClickTime, this.preTouchTime);
      } else if (this.preClickTime) {
        preTime = this.preClickTime;
      } else if (this.preTouchTime) {
        preTime = this.preTouchTime;
      }
      if (Math.abs(preTime - this.focusTime) < 20) {
        return;
      }
      this.focusTime = 0;
    }
    this.preClickTime = 0;
    this.preTouchTime = 0;
    event.preventDefault();
    if (this.state.visible) {
      this.setVisible(false);
    } else {
      this.setVisible(true);
    }
  },

  onDocumentClick: function onDocumentClick(event) {
    var target = event.target;
    var root = _reactDom2['default'].findDOMNode(this);
    var popupNode = this.getPopupDomNode();
    if (!_rcUtil.Dom.contains(root, target) && !_rcUtil.Dom.contains(popupNode, target)) {
      this.setVisible(false);
    }
  },

  getPopupDomNode: function getPopupDomNode() {
    // for test
    return this.popupDomNode;
  },

  getTipContainer: function getTipContainer() {
    if (!this.tipContainer) {
      this.tipContainer = document.createElement('div');
      if (this.props.getTooltipContainer) {
        var mountNode = this.props.getTooltipContainer();
        mountNode.appendChild(this.tipContainer);
      } else {
        document.body.appendChild(this.tipContainer);
      }
    }
    return this.tipContainer;
  },

  getPopupElement: function getPopupElement() {
    if (!this.popupRendered) {
      return null;
    }
    var props = this.props;
    var state = this.state;
    var mouseProps = {};
    if (props.trigger.indexOf('hover') !== -1) {
      mouseProps.onMouseEnter = this.onMouseEnter;
      mouseProps.onMouseLeave = this.onMouseLeave;
    }
    return _react2['default'].createElement(
      _Popup2['default'],
      _extends({ prefixCls: props.prefixCls,
        visible: state.visible,
        className: props.overlayClassName,
        trigger: props.trigger,
        align: props.align,
        placement: props.placement,
        animation: props.animation
      }, mouseProps, {
        wrap: this,
        style: props.overlayStyle,
        transitionName: props.transitionName }),
      props.overlay
    );
  },

  setVisible: function setVisible(visible) {
    if (this.state.visible !== visible) {
      if (!('visible' in this.props)) {
        this.setState({
          visible: visible
        });
      }
      this.props.onVisibleChange(visible);
    }
  },

  delaySetVisible: function delaySetVisible(visible, delayS) {
    var _this2 = this;

    var delay = delayS * 1000;
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
    if (delay) {
      this.delayTimer = setTimeout(function () {
        _this2.setVisible(visible);
        _this2.delayTimer = null;
      }, delay);
    } else {
      this.setVisible(visible);
    }
  },

  render: function render() {
    if (this.state.visible) {
      this.popupRendered = true;
    }
    var props = this.props;
    var children = props.children;
    var child = _react2['default'].Children.only(children);
    var childProps = child.props || {};
    var newChildProps = {};
    var trigger = props.trigger;
    if (trigger.indexOf('click') !== -1) {
      newChildProps.onClick = (0, _rcUtil.createChainedFunction)(this.onClick, childProps.onClick);
      newChildProps.onMouseDown = (0, _rcUtil.createChainedFunction)(this.onMouseDown, childProps.onMouseDown);
      newChildProps.onTouchStart = (0, _rcUtil.createChainedFunction)(this.onTouchStart, childProps.onTouchStart);
    }
    if (trigger.indexOf('hover') !== -1) {
      newChildProps.onMouseEnter = (0, _rcUtil.createChainedFunction)(this.onMouseEnter, childProps.onMouseEnter);
      newChildProps.onMouseLeave = (0, _rcUtil.createChainedFunction)(this.onMouseLeave, childProps.onMouseLeave);
    }
    if (trigger.indexOf('focus') !== -1) {
      newChildProps.onFocus = (0, _rcUtil.createChainedFunction)(this.onFocus, childProps.onFocus);
      newChildProps.onBlur = (0, _rcUtil.createChainedFunction)(this.onBlur, childProps.onBlur);
    }

    var className = props.prefixCls + '-wrap';

    if (this.state.visible) {
      className += ' ' + props.prefixCls + '-wrap-open';
    }

    return _react2['default'].createElement(
      'span',
      { className: className, style: props.wrapStyle },
      _react2['default'].cloneElement(child, newChildProps)
    );
  }
});

exports['default'] = Tooltip;
module.exports = exports['default'];